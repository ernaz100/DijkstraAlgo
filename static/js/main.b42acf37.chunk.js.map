{"version":3,"sources":["components/Node.jsx","components/PathfindingVisualizer.jsx","components/App.js","index.js"],"names":["Node","props","className","isStart","isFinish","isAnimated","isPath","isWall","id","onMouseDown","row","col","onMouseUp","onMouseEnter","PathfindingVisualizer","React","useState","grid","setGrid","orderOfVisit","isPressed","setPressed","handleMouseDown","newGrid","getNewGridWithWallToggled","handleMouseUp","handleMouseEnter","getNearestNode","nearest_node","distance","Infinity","forEach","rowIdx","node","colIdx","isVisited","markNodeASVisited","push","updateNeighborDistance","neighbor","path","updateTopNeighborDistance","GRID_WIDTH","updateRightNeighborDistance","GRID_HEIGHT","updateBottomNeighborDistance","updateLeftNeighborDistance","useEffect","nodes","currentRow","currentNode","type","onClick","console","log","end_node","i","length","setTimeout","document","getElementById","animatePath","animateVisited","map","rowIndex","key","nodeIdx","slice","newNode","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.b42acf37.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"../styles/Node.css\";\r\nfunction Node(props) {\r\n  const className = props.isStart\r\n    ? \"node start\"\r\n    : props.isFinish\r\n    ? \"node end\"\r\n    : props.isAnimated\r\n    ? \"node visited\"\r\n    : props.isPath\r\n    ? \"node path\"\r\n    : props.isWall\r\n    ? \"node wall\"\r\n    : \"node\";\r\n\r\n  return (\r\n    <div\r\n      id={props.id}\r\n      className={className}\r\n      onMouseDown={() => props.onMouseDown(props.row, props.col)}\r\n      onMouseUp={() => props.onMouseUp()}\r\n      onMouseEnter={() => props.onMouseEnter(props.row, props.col)}\r\n    ></div>\r\n  );\r\n}\r\n\r\nexport default Node;\r\n","import React from \"react\";\r\nimport Node from \"./Node\";\r\nimport \"../styles/PathfindingVisualizer.css\";\r\nfunction PathfindingVisualizer() {\r\n  const [grid, setGrid] = React.useState([]);\r\n  const GRID_WIDTH = 20;\r\n  const GRID_HEIGHT = 20;\r\n  const FINISHROW = 7;\r\n  const FINISHCOL = 12;\r\n  const STARTROW = 10;\r\n  const STARTCOL = 5;\r\n  let orderOfVisit = [];\r\n  const [isPressed, setPressed] = React.useState(false);\r\n  React.useEffect(() => {\r\n    const nodes = [];\r\n    for (let row = 0; row < GRID_HEIGHT; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < GRID_WIDTH; col++) {\r\n        const currentNode = {\r\n          col,\r\n          row,\r\n          id: col + row * GRID_WIDTH,\r\n          isStart: row === STARTROW && col === STARTCOL,\r\n          isFinish: row === FINISHROW && col === FINISHCOL,\r\n          isAnimated: false,\r\n          isVisited: false,\r\n          isPath: false,\r\n          isWall: false,\r\n          distance: row === STARTROW && col === STARTCOL ? 0 : Infinity,\r\n          path: [],\r\n        };\r\n        currentRow.push(currentNode);\r\n      }\r\n      nodes.push(currentRow);\r\n    }\r\n    setGrid(nodes);\r\n  }, []);\r\n\r\n  function dijkstra() {\r\n    let nearest_node = { isFinish: false };\r\n    while (!nearest_node.isFinish) {\r\n      //1 Get nearest node\r\n      nearest_node = getNearestNode(grid);\r\n      if (nearest_node.isVisited) {\r\n        console.log(\"Can't find closest Note\");\r\n        break;\r\n      }\r\n      //2 Mark node as visited and add to animation Array\r\n      markNodeASVisited(nearest_node);\r\n      //3 Update the neighbor distances and update path array for Path from Start to Finish\r\n      updateNeighborDistance(nearest_node);\r\n    }\r\n    animateVisited(nearest_node);\r\n    return;\r\n  }\r\n  function animateVisited(end_node) {\r\n    for (let i = 0; i <= orderOfVisit.length; i++) {\r\n      if (i === orderOfVisit.length) {\r\n        setTimeout(() => {\r\n          animatePath(end_node);\r\n        }, 100 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = orderOfVisit[i];\r\n        if (\r\n          document.getElementById(node.id).className !== \"node start\" &&\r\n          document.getElementById(node.id).className !== \"node end\"\r\n        ) {\r\n          document.getElementById(node.id).className = \"node visited\";\r\n        }\r\n      }, 100 * i);\r\n    }\r\n\r\n    return;\r\n  }\r\n  function animatePath(end_node) {\r\n    for (let i = 0; i < end_node.path.length; i++) {\r\n      setTimeout(() => {\r\n        const node = end_node.path[i];\r\n        if (\r\n          document.getElementById(node.id).className !== \"node start\" &&\r\n          document.getElementById(node.id).className !== \"node end\"\r\n        ) {\r\n          document.getElementById(node.id).className = \"node path\";\r\n        }\r\n      }, 75 * i);\r\n    }\r\n    return;\r\n  }\r\n\r\n  function handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(row, col);\r\n    setGrid(newGrid);\r\n    setPressed(true);\r\n    return;\r\n  }\r\n  function handleMouseUp() {\r\n    setPressed(false);\r\n    return;\r\n  }\r\n  function handleMouseEnter(row, col) {\r\n    if (isPressed) {\r\n      const newGrid = getNewGridWithWallToggled(row, col);\r\n      setGrid(newGrid);\r\n    }\r\n    return;\r\n  }\r\n  function getNearestNode(grid) {\r\n    let nearest_node = {\r\n      distance: Infinity,\r\n      row: STARTROW,\r\n      col: STARTCOL,\r\n    };\r\n    grid.forEach((row, rowIdx) => {\r\n      row.forEach((node, colIdx) => {\r\n        if (\r\n          node.distance < nearest_node.distance &&\r\n          !node.isVisited &&\r\n          !node.isWall\r\n        ) {\r\n          nearest_node.distance = node.distance;\r\n          nearest_node.row = rowIdx;\r\n          nearest_node.col = colIdx;\r\n        }\r\n      });\r\n    });\r\n    return grid[nearest_node.row][nearest_node.col];\r\n  }\r\n\r\n  function markNodeASVisited(node) {\r\n    node.isVisited = true;\r\n    orderOfVisit.push(node);\r\n    return;\r\n  }\r\n\r\n  function updateNeighborDistance(node) {\r\n    updateTopNeighborDistance(node);\r\n    updateRightNeighborDistance(node);\r\n    updateBottomNeighborDistance(node);\r\n    updateLeftNeighborDistance(node);\r\n\r\n    return;\r\n  }\r\n  function updateTopNeighborDistance(node) {\r\n    if (node.row === 0) {\r\n      return;\r\n    }\r\n    let neighbor = grid[node.row - 1][node.col];\r\n    if (node.distance + 1 > neighbor.distance) {\r\n      return;\r\n    } else {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.path = [...node.path];\r\n      neighbor.path.push(node);\r\n    }\r\n    return;\r\n  }\r\n  function updateRightNeighborDistance(node) {\r\n    if (node.col === GRID_WIDTH - 1) {\r\n      return;\r\n    }\r\n    let neighbor = grid[node.row][node.col + 1];\r\n    if (node.distance + 1 > neighbor.distance) {\r\n      return;\r\n    } else {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.path = [...node.path];\r\n      neighbor.path.push(node);\r\n    }\r\n    return;\r\n  }\r\n  function updateBottomNeighborDistance(node) {\r\n    if (node.row === GRID_HEIGHT - 1) {\r\n      return;\r\n    }\r\n    let neighbor = grid[node.row + 1][node.col];\r\n    if (node.distance + 1 > neighbor.distance) {\r\n      return;\r\n    } else {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.path = [...node.path];\r\n      neighbor.path.push(node);\r\n    }\r\n    return;\r\n  }\r\n  function updateLeftNeighborDistance(node) {\r\n    if (node.col === 0) {\r\n      return;\r\n    }\r\n    let neighbor = grid[node.row][node.col - 1];\r\n    if (node.distance + 1 > neighbor.distance) {\r\n      return;\r\n    } else {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.path = [...node.path];\r\n      neighbor.path.push(node);\r\n    }\r\n    return;\r\n  }\r\n\r\n  return (\r\n    <div className=\"grid\">\r\n      <button\r\n        type=\"button\"\r\n        className=\"btn btn-success start-button\"\r\n        onClick={dijkstra}\r\n      >\r\n        Start Dijkstra\r\n      </button>\r\n      <button\r\n        type=\"button\"\r\n        className=\"btn btn-warning start-button\"\r\n        onClick={reset}\r\n      >\r\n        Reset Grid\r\n      </button>\r\n      {grid.map((row, rowIndex) => {\r\n        return (\r\n          <div key={rowIndex}>\r\n            {row.map((node, nodeIdx) => (\r\n              <Node\r\n                key={node.id}\r\n                id={node.id}\r\n                row={node.row}\r\n                col={node.col}\r\n                isStart={node.isStart}\r\n                isFinish={node.isFinish}\r\n                isVisited={node.isVisited}\r\n                isAnimated={node.isAnimated}\r\n                isPath={node.isPath}\r\n                distance={node.distance}\r\n                isWall={node.isWall}\r\n                onMouseDown={handleMouseDown}\r\n                onMouseUp={handleMouseUp}\r\n                onMouseEnter={handleMouseEnter}\r\n              />\r\n            ))}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n\r\n  function reset() {\r\n    const nodes = [];\r\n    for (let row = 0; row < GRID_HEIGHT; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < GRID_WIDTH; col++) {\r\n        const currentNode = {\r\n          col,\r\n          row,\r\n          id: col + row * GRID_WIDTH,\r\n          isStart: row === STARTROW && col === STARTCOL,\r\n          isFinish: row === FINISHROW && col === FINISHCOL,\r\n          isAnimated: false,\r\n          isVisited: false,\r\n          isPath: false,\r\n          distance: row === STARTROW && col === STARTCOL ? 0 : Infinity,\r\n          path: [],\r\n        };\r\n        currentRow.push(currentNode);\r\n        if (\r\n          document.getElementById(col + row * GRID_WIDTH).className ===\r\n            \"node visited\" ||\r\n          document.getElementById(col + row * GRID_WIDTH).className ===\r\n            \"node path\"\r\n        ) {\r\n          document.getElementById(col + row * GRID_WIDTH).className = \"node\";\r\n        }\r\n      }\r\n      nodes.push(currentRow);\r\n    }\r\n    setGrid(nodes);\r\n    return;\r\n  }\r\n\r\n  function getNewGridWithWallToggled(row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = grid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n}\r\n\r\nexport default PathfindingVisualizer;\r\n","import PathfindingVisualizer from \"./PathfindingVisualizer\";\nimport React from \"react\"\nimport \"../styles/App.css\"\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App />, document.getElementById(\"root\"));"],"sourceRoot":""}